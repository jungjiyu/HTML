에러
	(1) Uncaught TypeError TypeError: Cannot set properties of null 
		: document.getElementById("아이디") 같은 코드를 실행했을떄 해당 요소를 찾지 못해서 그렇다
			원인1. 실제로 HTML 문서에 해당 아이디를 가지는 요소가 없음
			원인2. 자바시크립트가 HTML 문서의 해당 요소 등장 이전에 연결되서 못찾음
		: https://florescene.tistory.com/335

---------------------------------------------------------------------------------------------------------------------------------
UI User Interface>> 사용자와 시스템 간의 매개체. 
	GUI Graphic User Interface >> 사용자가 그림 통해 시스템에 접근
	CLI Command Line Interface >> 사용자가 명령어 통해 시스템에 접근


API  >> 보편적으로는 내부의 구현 사항을 숨기고, 외부에서는 필요한 것만 노출해둔것. 
	: 인터페이스라고도 할 수 있다
	(1) 구현해 놓은 코드를 다른 사람이 규격에 맞춰 사용할 수 있게 한 것.	
		: 서버와 서버 간의 매개체라고 볼 수 있다
		: 웹API.
	(2) 라이브러리나 프레임워크에서 제공하는 class나 함수들
	: https://velog.io/@gil0127/API%EB%9E%80-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC%EC%99%80-%ED%8F%AC%ED%8A%B8%ED%8F%B4%EB%A6%AC%EC%98%A4%EC%97%90-%EC%9C%A0%EC%9A%A9%ED%95%9C-%EB%8C%80%EB%B0%95-%EC%82%AC%EC%9D%B4%ED%8A%B8-%EA%B3%B5%EC%9C%A0

---------------------------------------------------------------------------------------------------------------------------------
예전엔 서버쪽에서 해야됬던걸 이젠 클라이언트선에서 처리 가능하다.


프론트엔드관련 프워, 라리
	프레임워크 >> react, vue ,Node.js ..
		Node.js >> js 를 백엔드 개발에 사용할 수 있게 만든 프레임워크

	라이브러리 >>jQuery

---------------------------------------------------------------------------------------------------------------------------------

구조적 프로그래밍 >> 절차지향 프로그래밍>> 객체 지향 프로그래밍>> 함수형 프로그래밍 
	: 구조적 프로그래밍 : 기능 중심적 개발하는 언어

	: 절차지향프로그래밍 언어 : "순차적으로" 처리하는 언어
		: 함수만 있음

 	: 객체지향프로그래밍 언어 : object 단위로 처리하는 언어
		: 함수와 객체가 있음
		: 추상화 캡슐화 상속성 다형성의 특징을 가짐
		: 클래스가 일급객체가 된다.
			: 일급 객체 >> 걍 일반적인 객체를 말하는 거임

	: 함수형 프로그래밍 언어, 비절차형 프로그래밍 언어 : "순수 함수"를 사용하여 처리하는 언어. 	
		: 순수 함수 ) 동일 입력값에 대해 항상 동일 리턴값을 반환하며 외부 영향을 받지 않는 함수. 그러니까 side effect 가 없단 말.

		: 실행 순서를 지정할 필요가 없다
		: 함수 "자체" 가 일급 객체 가 된다.


---------------------------------------------------------------------------------------------------------------------------------

스크립트 언어 : 이미 존재하는 소프트웨어를 제어하기 위한 용도로 사용되는 언어
	: 소스 코드를 컴파일(Compile)하지 않고도 실행할 수 있다.
	: 스크립트 언어 ⊂ 인터프리트 언어
https://velog.io/@jkijki12/%EC%BB%B4%ED%8C%8C%EC%9D%BC-%EC%9D%B8%ED%84%B0%ED%94%84%EB%A6%AC%ED%84%B0-%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8

---------------------------------------------------------------------------------------------------------------------------------

전역 객체 
	: https://poiemaweb.com/js-global-object
	: 최상위 객체를 의미한다.
	: 성질
		: 전역 객체의 자식 객체를 사용할 때, 전역 객체는 생략 가능하다.  
			ex) document.getElementById( ); // window.getElementById( )  

		: 전역변수를 프로퍼티로 가진다.
			ex) 
				let a = 'AAA'; 
				console.log(a); // console.log(window.a);	

---------------------------------------------------------------------------------------------------------------------------------
HTML, CSS , JS
	: HTML >> 웹 문서 내용 구성
	: CSS >> 웹 문서 레이아웃, 스타일 지정
	: JS >> 동적인 처리 가능
		

---------------------------------------------------------------------------------------------------------------------------------

BOM 과 DOM
	: BOM  Browser Object Model 브라우저 객체 모델
		: 브라우져와 관련된 객체들의 집합
		: document , location ,  history ... 등


	: DOM Doucument Object Model 문서 객체 모델
		: 웹페이지 (html , xml 문서 등)를 구조화 시켜 활용 가능한 객체(object) 형태로 만든 일종의 web api. 인터페이스.
		:  DOM ⊂ BOM

		: tree 자료구조를 가진다. 계층적으로 표현된다.
			document 노드 : 최상위 "루트" 노드 
				: 해당 HTML 문서 전체를 나타내는 노드. 
					: html 문서 당 하나 씩 존재
				: document 객체를 가리킴. 
					:  주의
						0. document 객체가 DOM tree 에서 최상위 노드이긴 하지만, 전역 객체인건 아니다. (전역 객체는 window 이다)
						1. html 이 루트 "요소"라고는 하지만, DOM 에서 루트 노드는 아니다!

					:  최상위 객체인 window 객체로도 접근 가능 (window.document)

				: element 노드를 자식 노드로 함

			element 노드 
				: 모든 html 요소( <html> 포함 )를 노드화 한 것.
				: attribute 노드, text 노드를 자식 노드로 함

			attribute 노드
			 
			text 노드 : 리프 노드 
				: html 문서 내의 텍스트를 노드 화 한 것



		:  JS "등"의  스크립팅 언어를 통해 조작 가능
			: 조작이 가능한거지, js 내에  DOM이 있는게 아니다
			: DOM 은 특정 프로그래밍 언어에 의존하지 않는 독립적인 인터페이스
			: js 에서는 "document " 객체를 통하여 DOM 에 접근, 사용 가능하다.
				: js 에서는 document 객체가 DOM tree 의 최상위 노드.

		: DOM 의 동적 생성과 정적 생성
			: 정적 생성 >> HTML 문서에 존재하는 태그로 노드를 생성하는 것. 
			: 동적 생성 >> 스크립팅 언어를 통해 HTML 문서에 없는 노드를 만드는 것.

		: https://www.codestates.com/blog/content/dom-javascript

---------------------------------------------------------------------------------------------------------------------------------

자바스크립트는 최상위에 단 1개의 전역 객체를 가진다.
	: 전역 객체의 이름은 자바스크립트 사용 환경 따라 다르다
		웹 브라우저에서의 자바스크립트 전역객체명 >> window
		node.js 에서의 자바스크립트 전역 객체명 >> global
	: 전역객체는 생략해서 사용 가능하다.
	: 자바스크립트의 모든 전역변수들은 이 전역객체의 속성이 된다
		let foo = 1;
		window.foo; // 1

---------------------------------------------------------------------------------------------------------------------------------

렌더링 엔진 : HTML, CSS를 파싱한 결과물을 화면에 표시하는 역할	
	: webkit, blinck 등 

JS interperter : 자바스크립트 코드를 해석하고 실행

기본적인 HTML , CSS 렌더링 과정
		1. HTML 읽고 파싱(토큰화하여 parse tree 생성)하여 DOM tree 생성
		2. CSS 를 읽고 파싱하여 CSSOM tree 생성
		3. DOM 과 CSSOM 을 합쳐(attatchment하여) Render tree 생성
		4. Render tree 를 기반으로 렌더링

	: JS 로 인한 영향
		: <head> 에 삽입한 경우 
			: parsing HTML --> fetching JS --> executing JS --> parsing HTML
			: HTML 파싱하다가 , 멈춘 후 js fetching 을 하고 excuting 이 완료 되면 , HTML 파싱을 재개한다
			: 문제점
				1. js 파일이 클 경우 파싱을 하다만 페이지를 사용자에게 오랫동안 보여주게 된다
				2. script 파일이 아직 파싱되지 않은 DOM 요소에 접근하여 문제가 발생할 수 있다

		: <body> 에 삽입할 경우 
			:  parsing HTML --> fetching JS --> executing JS
			: HTML 파싱을 완료한 후 JS 파일을 다운로드 받고 실행
			: 장점 >> HTML 파싱이 완료된 페이지를 빠르게 볼 수 있다.
			: 담점 >>  js 에 의존적인 컨텐츠를 보는데에는 오래 걸린다.


	******: defer 속성과 함꼐 삽입할 경우 
			: parsing HTML & fetching JS --> executing JS  
			: HTML parising 과 fectcing 을 병렬로 하고, 이가 모두 끝나면 js 를 excute 하기 때문에 순서에도 문제가 발생하지 않고 비교적 빠르다

		: https://happytape.tistory.com/38
		: https://stackoverflow.com/questions/24297829/execute-write-on-doc-it-isnt-possible-to-write-into-a-document-from-an-asynchr
			: asynchronously 하게 로드된 스크립트. 동적 로드된 스크립트는 문서가 완전히 파싱되고 닫힌 후에 실행된다. 따라서 그러한 스크립트 파일에는 document.write( ) 와 같은 것을  포함하면 안된다. (할 순 있지만, 원하는 방식대로 실행되지 않는다.) 대신 innerHTML , appendChild( ) , insertBefore( ) 같은걸 DOM 조작을 위해 사용할 수 있다.

---------------------------------------------------------------------------------------------------------------------------------
자바스크립트
	: "동적인" 웹 페이지 작성을 위한 언어
	: 모든 웹 브라우저는 js 소스를 읽고 실행하는 JavaScript Interpreter 를 내장 >> 웹 문서에서 js 를 사용 가능
	: css , html 과 다르게 대소문자 구별됨
	<script> 태그 : 
		: 웹 문서의 어디든 위치 가능하고, 여러개 작성 가능.
		: 삽입된 "그 위치"에서 실행됨.
		기능
			1. 시작, 끝 태그 사이에 자바스크립트 코드 작성 가능
			2. src 속성으로 외부 스크립트 파일을 해당 문서와 연결 가능


	: 작성 방법
		(-1) 인라인 자바스크립트 : 태그 내에 직접 js 코드 작성
			: ' on이벤트명 '속성을 활용해 "자바스크립틈명령어" 를 할당하는 꼴로 사용
				ex) <button onClick="window.alert('jejejee');"> 버튼</button>

		(0) 내부 자바스크립트 : 해당 파일의 <script> 태그 내부 직접 js 코드 작성
		(1) 외부 스크립트  : .js 확장자의 스크립트 파일에 js 소스를 작성하고, HTML 문서에서 <script> 태그의 src 속성을 이용해 해당 스크립트 파일을 연결하여 사용
			: 장점 
				1. 코드 재사용 
				2. 유지보수




	: 자바스크립트 != 자바	
		: 공통점 >> 객체 지향을 지원한다.
		: 자바
			1. jvm 위에서 실행된다
			2. 컴파일 언어  : 번역 시간과 실행 시간이 별개이다.
			3. 객체 지향 언어
			4. 변수의 타입 선언 "반드시" 필요

		: 자바스크립트
			1. 브라우저 위에서 실행된다
			2. 인터프리터 언어. 스크립트 언어 : 번역과 실행이 동시에 일어난다.
			3. 구조적 프로그래밍, 함수형 프로그래밍, 객체지향 프로그래밍 , 객체 지향 프로그래밍 "기능"을 지원
				: 객체 지향 언어 != 자바 스크립트  
				: 함수 자체를 객체로 한다
				: 람다식도 지원한다

			4. 변수의 타입 선언 없어도 사용 가능




JS 문법 기초

	: 식 experssion >> 어떠한 값을 만들어내는 모든 것. (단순 연산 식 뿐 아니라 함수도 식)
	: 문 statement >>   명령어
		: 세미콜론을 꼭 쓸 필욘 없지만 관습적으로 써준다.
		: 식 ⊂ 문


	: js 실행 중 발생한 에러는 콘솔 창에 표시된다 >> 뭔가 이상하게 작동하면 에러난건 없는지 콘솔창 열어 확인해보자.


	: 자바스크립트 스타일 가이드. 코딩규칙
		: 자바스크립트가 워낙 유연하다보니 코딩 방식이 중구난방일 수 있는데 이를 방지하고자 권고되는 스타일/
		: 보통 구글의 자바스크립트 스타일 가이드 를 사용함
			: https://google.github.io/styleguide/jsguide.html
			(1) 들여쓰기로 가독성 높임
				: tab 은 시스템 환경마다 다르게 보일 수 있으므로 space 치는 걸 권장. 보통 2 번 침. (4 개는 과다)
			(2) 공백으로 가독성 높임
				: 연산자와 연산자 사이에 공백 좀 넣어라
					ex ) 1+2==10 >> 1 + 2 == 10

			(3) 세미콜론으로 문장 구분
				: 세미콜론 필수는 아니지만 없으면 가독성 떨어지고 디버깅하기도 어려움

			(4) 주석 작성
				: 이해 돕기 위해 // 혹은 /* */ 사용해라

			(5) 식별자 규칙
				: 첫 글자는 문자 혹은 _ , $ 로만 시작 가능
					: 이후에는 맘대로 기호 사용 가능 . ( _ 뿐 아니라 - 도 사용가능)
				: 예약어는 식별자로 사용 불가

	: 주석문 >> // (한줄)혹은 /* */ (여러줄)



	: 리터럴 literal ) 값 그 자체. .
		1. 정수 리터럴 
			2진수 리터럴 >> 0b 접두사+2진수표기숫자
			8진수 리터럴 >> 0o 접두사 + 8진수표기숫자
			16진수 리터럴 >> 0x 접두사 + 16진수표기숫자

		2. 실수 리터럴 : 부동소수점 방식이라 부정확
		3. 문자열 리터럴 : " 혹은 ' 로 감싼다
		4. 배열 리터럴: [ 값1, 값2 , .. ]
		5. 딕셔너리 리터럴: { "키1":"값1","키2": "값2","키3": "값3" ... }	
			:  { 키1 :"값1", 키2 : "값2",키3: "값3" ... }	로 해도 되긴 한다. 그러면 자동으로 " " 붙여준다


	: 변수 variable
		: https://velog.io/@wlwl99/%EB%B3%80%EC%88%98-%EC%84%A0%EC%96%B8-%EC%B4%88%EA%B8%B0%ED%99%94-%ED%95%A0%EB%8B%B9-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85
		: https://velog.io/@bathingape/JavaScript-var-let-const-%EC%B0%A8%EC%9D%B4%EC%A0%90
		
		: 데이터를 저장하는 상자

		: 호이스팅 >> 변수의 "선언문"을 선두로 옮긴 것 처럼 해석하는 특성
			: js 에서 모든 변수는 호이스팅 된다.

		: scope ) 변수의 유효 범위.
			: 전역변수 global >> 모든 곳에서 참조될 수 있음
				: 지역 변수가 아닌 변수.

			: 지역변수 local >>해당 지역 및 하위 지역에서만 참조 가능
				: js 는 원래 함수 스코프만 따랐지만, let 과 const 의 등장 이후 블록스코프형성도 가능해졌다
				: 변수가 아무리 호이스팅 된다해도 지역변수라면 해당 스코프 내에서만 사용 가능하다.



				: 블록 scope >> 블록 생성과 생성과 함께 발생하는 scope
					: 화살표 함수, let , const
						:  var 은 블록스코프를 무시한다. 그러니까 단순 중괄호만 쳤을 땐 밖에서도 인식 잘 된다.

					: for 문의 ( ) 은 해당 for 문과 바인딩된 { } 에 대한 블록 스코프라고 보면된다.
					: 함수⊂ 블록 이므로 블록 scope 인식 되는 키워드들은 함수 scope 도 잘 인식한다.


				: 함수 scope >> 함수 생성과 함께 발생하는 scope
					: var , (화살표함수, let, const)


		: 사용방법
			step 1. 선언 : var, let , const 키워드 중 하나 택하여 선언하는것
				: 일반적인 프로그래밍 언어와 다르게, 해당 변수가 어떤 자료형의 값을 저장하게 할건지 결정한다는 느낌이 아니라. ( 키워드를 뭘 쓰든 모든 자료형의 값을 담을 수 있따), 변수 자체의 종류를 정하는 느낌이다
				: 키워드 권장 방향 >> 변수 선언엔 기본적으로 const 를 사용하고, 재할당이 필요한 경우에만 let 을 사용한다. 
					: const 의 사용을 적극 권장하는 것은 의도치 않은 재할당을 방지해주기 떄문.
					: let 의 사용을 var 보다 권장하는 것은 
						1. 재선언 방지
						2. 함수 스코프보다 블록 스코프가 더 예측 가능함

				sol0. const 로 선언 
					: 상수값을 가지는 변수 선언.  immutable 하다 (변수에 값 재할당 불가)
					: 변수 재선언 불가
					: 선언단계와 초기화단계와 할당단계 동시에 이뤄진다.
						: 선언과 함께 초기화 값을 주지 않으면, 에러가 난다.

				sol1 . let 으로 선언
					: mutable 하다 (변수에 값 재할당 가능)
					: 변수 재선언 불가
					: 선언단계와 초기화 단계가 분리되어 실행된다.
						: 초기화는(undfined 부여) 실제 코드에 도달했을 떄 이뤄진다.
						: 할당도 실제 코드에 도달했을 때 이뤄진다.
						: 초기화 되지 않은 변수가 호이스팅 되는거라, 변수 선언문 이전에 해당 변수의 참조를 하면 에러가 난다.
						: 참고로 변수 선언 과 초기화 사이엔 해당 let 변수는 TDZ Temporal Dead Zone 사각지대에 있어서, 못찾게 된다고 한다.
				
				sol2 . var 로 선언
					: 단점 >> 변수를 여러번 재선언 가능
					: 선언단계와 초기화단계가 동시에 실행된다.
						: 초기화된 변수가 호이스팅 되는거라  변수 선언문 이전 위치에서도 해당 변수의 참조가 가능하다(undifined 로 값이 나오긴 하겠지만)

				sol3, 선언 없이 사용
					: (어디서 선언하건 ) 전역변수 취급된다.
						function func() { variable = 1; }
						func();
						console.log(variable); // 1
					: 근데 선언과 초기화 가 동시에 실행되진 않는 것 같다. 선언문 이전에 사용하면 에러난다. 
			step 2. 초기화 : 자동으로 undifined 값을 부여 , 메모리공간을 확보하는것
			step 3. 할당 : 실제 값을 부여하는 것




---------------------------------------------------------------------------------------------------------------------------------


	: 대화상자 dialogue box >> 간단한 알림 내용을 표시하거나, 사용자에게 어떤 값을 입력하게 하는 창

		1. window.alert("메시지") : 단순 메세지만 표시하는 대화상자
		2. window.confirm("메시지") : [확인] , [취소] 버튼을 메세지와 함께 표시하여 간단한 의사 표현을 입력받을 수 있는 대화 상자
			: 리턴값 >> 사용자가 '확인' 버튼을 누르면 true, '취소' 버튼 누르면 false 반환.
			: 암기 tip >> 일방적인 통보. confirm.

		3. window.prompt( "메시지" )  혹은  window.prompt( "메시지" , "텍스트필드에디폴트로표시할값" )  : 메세지 텍스트 필드가 있는 대화상자
			: 리턴값 >> 입력 필드에 입력한 내용을 "문자열" 타입으로 리턴
				: 입력 받은 값으로 숫자 연산을 하고 싶으면 parseInt( ) 처리는 필수다.
			: 암기 tip >> 뭔가 티키타카가 있다. 프롬프트.



	: 웹 브라우져 화면에 출력
		document.write( 출력할내용)
			: 단순 결괏값 확인용으로 많이 쓴다
			: arg 로 들어간 문자열이 html 문서에 삽입된다.
				: 태그 쓸 수 있다.
				: 줄바꿈은 '\n' 같은게 안먹히고 <br> 같은것만 먹힌다.



	: 콘솔에 출력
		console.log( 출력할내용 )
			: 콘솔에 출력하는 거지, html 에 삽입되는게 아니다,
				: \n 같은거 잘 먹고, 태그는 못쓴다




---------------------------------------------------------------------------------------------------------------------------------


	: 데이터 타입 NNOSUB
		: 주의 >> undefined 는 자료형이지만 , NaN은 하나의 자료형이 아니고 Number 자료형에 속한다.
			:https://www.codeit.kr/community/questions/UXVlc3Rpb246NjA2ZDIzZmJjNDMwYmU2NTVlNGJkZWJk

		1. 원시(primitive) 자료형 : 값을 바꿀 수 없는 자료형 (재할당은 물론 가능하지만, 그 값 자체는 수정 불가하단거)
			(1) Number : 숫자 
				: 정수 혹은 실수 혹은 NaN
					: NaN Not a Number 
						: 숫자가 아님을 나타내는 특별한 값
						: NaN 값을 확인하는 법
							: NaN 은 어떤 값과도 동등 하지 않아 NaN == NaN 혹은 NaN == NaN 하면 false 나온다. 따라서 isNaN( ) 이라는 별개의 함수를 사용하여 확인해야한다.
								ex) 
								 NaN == NaN // false
								 isNaN(NaN)  // true
								 isNaN(123)  // false
								 isNaN("Hello") // true
						
			(2) String : 문자열
				: 줄바꿈을 표현하는 방법
					1. 웹 페이지 상 >> 문자열에 <br> 표기
					2. 콘솔 상 >> 문자열에 \n 표기

				: " 와 ' 의 구분 없음 but 백틱( ` ) 은 다름 주의
					: 일반적인 문장은 ' , " , ` 으로 모두 표현 가능하지만, 백틱의 기능을 사용하기 위해선 반드시 백틱으로 표현해야된다.
					: 백틱 `
						: 기능
							1. ${ } 를 사용해 문자열 중간에 변수 삽입을 간편하게 할 수 있게 해준다.
								: 그러니까 일종의 format 역할
								: 꼭 백틱 안쓰고 + 연산자를 통해 문자열 중간에 변수 삽입을 할 수 있긴 하지만 번거로우니까..	
							2. 코드상 백틱 내에 줄바꿈이 있으면 "콘솔" 상에서 실제로 줄바꿈이 일어나게 한다.
								: \n을 사용할 필요가 없다.


			(3) Undefined : undefined 값 하나만을 포함한다.
				undefined >>  값 할당이 아직 안됬을 때의 값.

			(4) null : null 값 하나만을 포함한다
				null>> 데이터가 유효하지 않은 상태를 나타내는 할당된값.
				주의 !!! : typeof null 은 null 이 아니라 object 라고 한다. 이는 자바스크립트의 버그 지만, 레거시 코드가 워낙 많아 고쳐지지 않고 있다.

			(5) Boolean : true 혹은 false

		2. Object 자료형 : primitive 자료형이 아닌 모든 자료형
			: 객체 == 속성과 메서드를 그룹핑한것
			: js 에서는 원래 객체라는 개념이 없지만, '딕셔너리' 를 이용하여 객체 기능을 지원한다.

			(0) Function 자료형
				: 화살표 함수를 포함한 함수를 의미.
				: typeof 쓰면 function 이라고 나온다



			(1) 배열 array list
				: https://velog.io/@tbh05158/Array-List

				: 자바스크립트의 배열은 리스트 형태의 고수준 객체로, 사이즈가 "동적"인 배열이다.
				: 하나의 배열에 여러 자료형의 데이터를 가능
				: 인덱스로 접근.
				: 선언 방법
					1. 배열리터럴 사용 >> 변수명 = [값1, 값2, 값3 .. ];
					2. new 키워드 사용 >> 변수명 = new Array( 크기 );

				: 프로퍼티
					1. length >> 길이 반환

				: 메서드
					: https://offbyone.tistory.com/133
					1. push( 값 ) >> 젤 끝에 값 추가
					2. pop( ) >> 젤 끝 값 제거 밑 반환
					3. shift( ) >> 젤 처음값 제거 및 반환
 					4. unshift( 값 ) >> 젤 처음 위치에 값 추가
					5. concat( 배열1, 배열2 , .. ) >> 배열을 연결한 꼴의 배열을 반환
					
				: 배열 그대로 출력하면 전체 요소가 보기 좋게 출력됨
 				: 현재 배열의 길이에서 건너뛰어 인덱스를 사용하여 값을 입력하면 가운데에는 undefined 가 삽입됩



			(2) Dictionary 딕셔너리
				: 요소가 key 와 value 의 쌍의 형태를 띰.
				: 선언 방법: 딕셔너리리터럴 사용 >> 변수명 = { "키1":값1 , "키2":값2 .... }

				: 키(컨텐츠) 를 기반으로 찾느다.		
				: 값 접근 방법
					: 어떻게 지가 알아서 탁 갈까? >> hash function 을 사용한다.
						: 입력이 있으면 결과값이 있다. hash("mother") 의 값을 get 해서 해당 값으로 배열에 접근한다.

					1. 키 기반 >> 변수["키"] 
						: 주의 ) 변수[키] 가 아니다

					2. 도트연산자 사용 >> 변수.키
						: 딕셔너리는 사실 객체라서 가능



	: 자바스크립트의 객체
		:자바스크립트에서는  기존 기능을 재활용해서 객체지향 흉내를 내는거지, 실제로 객체지향이 아니다. 
			: 원리 >> 파이썬의 dictionary 의 사용법.
			: 자바스크립트에서 완벽하게 객체지향 학습을 하려고 하지 말것
				c에서 ary[1] 을 *(a+1) 로 내부적으로 수식해서 계산하는거랑 비슷하게 사실 변수["키"] 는 내부적으로 변수.키 라는 것이다.


		: 종류
			(1) 내장객체 : js 에 내장된 객체
				1. BOM : 브라우저 관련 객체들
				2. DOM :  HTML 문서를 파싱해서 각 요소들을 객체 트리로 정의한 것

			(2) 사용자 정의 객체 : 개발자가 정의해 쓰는 객체
				: https://ablue-1.tistory.com/1
				1. 딕셔너리 리터럴 할당 : 재사용은 불가	
				2. 생성자 함수 활용 : 재사용 가능
					: 생성자 함수 형태
						function 대문자시작함수명( arg1 , arg2 ...  ){
							this.프로퍼티명1 = arg1;
							this.프로퍼티명2 = arg2;
						. . .
						}

					: new 함수명(arg1, .. ) 시 일어나는일 
						: https://velog.io/@jakeseo_me/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%9D%BC%EB%A9%B4-%EC%95%8C%EC%95%84%EC%95%BC-%ED%95%A0-33%EA%B0%80%EC%A7%80-%EA%B0%9C%EB%85%90-16-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-new-%EC%97%B0%EC%82%B0%EC%9E%90-sojvdjln1q

						1. 새로운 빈 오브젝트를 생성
						2. 생성한 오브젝트를 함수의 this와 바인딩
						3. 새롭게 생성된 오브젝트의 프로퍼티에 "proto" 라고 불리는 생성자 함수의 프로토타입 오브젝트를 추가
						4. return this 로 생성된 객체 반환
							: return this 가 없어도 자동적으로 붙여준다.


		: 객체 생성 방법
			1. new 키워드 사용 
				내장객체타입 -->  new 객체타입명( arg1, arg2 .. ); 
				사용자정의타입 --> new 함수명( arg1, arg2 .. );

			2. 각 타입에 맞는 리터럴 할당 
				ex) array 타입 --> [ 값1, 값2 . . . ] ;


		: 객체 활용 방법
			: 멤버 접근 방법 
				1. 도트 연산자 사용 >> 객체명.멤버명
				2. 딕셔너리적 접근 >> 객체명["멤버명"]
		










생성자 흉내내기 : this

대문자로 시작하는 함수 >> 클래스 이다.
	function User(name, isAdmin) >> User 은 클래스이다.



	: 연산자
		+ 연결 연산자 
 			: 하나이상의 피연산자를 문자열로 하면, 자동으로 나머지 피연산자를 문자열로 형변환하여 이어준다
				: 그렇다고 변수의 경우 변수명으로써 더해지는게 아니라 해당 값이 잘 들어가므로 걱정x
			: 교환법칙성립안하는거 주의











	연산자
		(0) 자료형연산자 typeof : 해당 변수, 값의 자료형명을 문자열로 반환한다
			: typeof 변수 혹은 typeof 값 과 같이 괄호 없이 바로 쓸 수 있지만. 화살표함수를 arg 로 하는 경우 괄호 명시 필수다.
			: 참고로 함수를 대상으로도 사용 가능하고, 이경우 function 으로 나온다

		(1) 산술 연산자  + - * / % 
			: 몫 연산자 빼고 모두 지원 (몫 연산자는 파이썬 빼고 다 없다)
		(2) 증감 연산자 ++  -- 
		(3) 문자열 연산자 + 
			: 왼쪽부터 오른쪽으로 차례대로 더해진다.
				:  "교환법칙" 성립 안함. 그러니까 피연산자 순서 따라 문자열의 결과가 달라질 수 있다.
					document.write( '1==1 : '+ 1 == 1 )  ; // false
					document.write( '1==1 : '+ (1 == 1) )  ; // 1==1 : true

		(4) 비교 연산자  ==, ===,   != ,  > , < , >= , <= 
			: == 와 === 
				: === 를 써야하는 이유 >> 프로그래머의 혼란 방지 차원

				== equal operator 비교연산자
					: 맥락상 값이 같으면 모두 true 를 리턴한다 
						'100' == 100 // true
						'1' == true // true
						'true' == true // true
						null == undifined // true		

						: 예외 >> 객체와 NaN
							: 객체는 메모리 주소를 참조해서 그렇다.
							let a = [ 1 , 2 , 3] ; let b = [1, 2 , 3];
						 	a == b // false
							NaN == NaN // false


				=== STRICT equal operator 엄격한 비교 연산자
					: 자료형과 값이 모두 일치해야 true 를 리턴한다
						NaN === NaN // false

						'100' === 100 // false
						'1' === true // false

			: != 와 !==
				!= 
					: 자료형과 값 둘 중 모두 다르면(맥락상 다르면) true 를 리턴한다
 
				!==
					: 자료형과 값 둘 중 하나라도 다르면 true 를 리턴한다


		(5) 논리 연산자 && , || , !
			



	this
		this 에 바인딩 되는 값
			(1) 전역 공간의 this >> 전역 객체( == window 객체)
			(2) 메서드 내부의 this >> 해당 메서드를 호출한 객체
			(3) (화살표함수 제외)함수 내부의 this >> 전역객체( == window 객체)
				: 함수 내부의 this 는 존재하긴하지만, 값이 "지정"되지 않는다. this 가 지정되지 않은 경우 this 는 자동으로 전역 객체를 바라보기 때문에, 결국 함수 내부의 this는 전역 객체가 된다.

			(4) 화살표 함수 내부의 this >> 상위 scope 에서의 this 를 참조한다.
				: 화살표 함수 내부엔 this 가 "아예" 없다. js 에서는  현재 scope 에 해당 식별자가없으면 상위 scope 로 올라가서 찾는데, 그와 같은 원리이다.


		: https://velog.io/@padoling/JavaScript-%ED%99%94%EC%82%B4%ED%91%9C-%ED%95%A8%EC%88%98%EC%99%80-this-%EB%B0%94%EC%9D%B8%EB%94%A9



	유명한 함수
		document.write( " html 형식의 문자열" ) 
			: 요약 >> 페이지 로드를 마치기 이전에 읽힌 docuemnt.wirte 는 해당 HTML 페이지에, 페이지 로드를 완료한 이후 읽힌 document.write 는 새로운 HTML 페이지에 해당 내용을 추가한다.
				: 페이지 로드 될 때 명시된 document.write(  ) 는 arg 를 해당 HTML 문서 내부에 주입한다
					: f12 눌러서 확인해보면 실제로 wirte한 내용이 html 소스상에 추가되었음을 볼 수 있다
					: <script /> 읽히는 시점에 js 가 fetch, excute 되고, 그떄 wirte( ) 도 실행되는 것이라 <script> 가 <head> 부분에 있으면 wirte( ) 내용은 해당 페이지의 가장 윗부분에 추가되고, <body> 의 가장 끝 부분에 있으면 해당 페이지의 가장 아랫 부분에 추가된다.

				: 페이지가 다 로드된( js fetch, excute 까지 다 된) 후에 document.write( ) 하면,  기존 HTML 문서를 다 밀어버리고 arg 내용으로 덮는다. (그래서 이름이 append 이런게 아니라 write( ) 인가보다 )
				: https://we-always-fight-with-code.tistory.com/39
				: https://ko.javascript.info/modifying-document

			: HTML 에 포함될 내용을 쓰는 것이라 '\n' 은 안먹히고 <br> 이 먹힌다




		console.log( " 콘솔에 출력할 내용") 
			: 주로 디버깅 용도로 많이 쓴다.


	함수 
		: 전역 변수와 지역 변수
			: 전역 변수 == 함수 외부에서 선언된 변수
			: 지역 변수 == 함수 내부에서 선언된 변수

		: 함수의 정의 방식
			(1) 함수 선언문
				: !! 반환형은 명시하지 않는다
				: function 키워드와 함수명 명시 필요
				: 호이스팅 된다

			function 함수명( 매개변수1, 매개변수2 .. ){
				. . .
				return 어쩌구;
			}
		
			(2) 익명함수
				: 변수에 함수 선언문을 할당해 사용하는 것
					: function 키워드는 필수,  함수명은 명시 불필요 
					: 변수의 호이스팅 규칙을 따른다
					: 자바의 람다식과 비슷.

				: 주의  >> 함수명은 생략 해도 (  )는 필수로 써줘야됨

				변수명 = funcition ( 매개변수1, 매개변수2 .. ){
					. . .
					return 어쩌구;
				}


			(3) 화살표 함수
				: 익명 함수 선언을 더 간단화 한 것
				: 특징/주의
					1. 변수의 호이스팅 규칙을 따른다
					2. 무조건 익명함수로만 사용가능하다
					3. 메서드나 생성자 함수로 사용 불가
				
				: 기본 형식 
					: 화살표 함수도 하나의 할당 문이므로 끝에 ; 명시 잊지 말자

					변수명 = (매개변수1, 매개변수2,  . . ) => {  
							
							. . .
							return 어쩌구; };
			
			
 
				: 표현 방법
					1. 매개변수  ( , .. , )
						(1) 매개변수가 하나만 있는 경우 : 소괄호 표시 생략 가능
						(2) 그 이외의 경우 : 소괄호 표시 필수

					2. 함수 몸체 { ... }
						(1) 문장이 리턴문만 있으면 되는 경우 
							: return 키워드를 생략 가능한데, 생략할꺼면 중괄호도 필수적으로 생략해야됨

						(2) 그 외의 경우
							: return 키워드와 중괄호를 필수적으로 사용 필요				 
				


			
	HTML 요소에서 정보 뽑기		
		: HTML 요소를 구하는 법	
			(1) document. getElementById( '아이디' );
 				:  Id 를 이용하여  접근
				: 주의 >> '아이디' 혹은 "아이디" 로 써야된다. 안그럼 변수가 되잖아.

		: 구한 객체에서 정보 뽑고, 변경하는 법 >> 변수명.속성명	
			: 주의 >> 변수.value 는 항상 String 타입을 반환한다. 
				: 숫자 계산을 원하면 parseInt 필수다.
			ex) 
			// 요소 얻어옴
				let x = document.getElementById(아이디); 
				let y = document.getElementById(아이디);
				let z = document.getElementById(아이디);

			// 정보 뽑음
				let a = x.value;
				 let b = y.value;

			// 정보 수정
				z.value=a+b;


	제어문 >> 자바와 ㅈㄴ 똑같다
		: 조건문 
			(1) if ... else if ... else 문
			(2) switch 문

		: 반복문
			: break >> 가장 가까운 '루프'를 탈출
			: continue >> 해당 반복의 나머지 부분을 건너뛰고 다음 반복으로 넘어감.
			(1) for문
				: 루프제어 변수는 되도록 for문 안에 적는다. 
					1. 번잡스럽다
					2. 변수의 사용 범위를 for 문 내부로 제한하기 위해
					: http://www.soen.kr/book/java/book/513.htm
			(2) while 문
			(3) do-while 문 << 끝에 ; 빼먹지 않기 !

	
